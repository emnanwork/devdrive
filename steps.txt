
pip install virtualenvwrapper-win
mkvirtualenv devdriveenv
pip install django
django-admin startproject devdrive

python manage.py startapp core
register core app in devdrive main folder in INSTALLED_APPS (settings.py file)
in core folder, models.py file, import abstract user

in settings.py file set AUTH_USER_MODEL to 'core.CustomUser'

import user admin in admin.py in core folder
import CustomUser
create CustomUserAdmin 
run migrations
    python manage.py makemigrations
    python manage.py migrate

create superuser
python manage.py createsuperuser

python manage.py runserver


python manage.py startapp blogapp

create index function in views.py in blogapp folder
create templates folder in blogapp
create blogapp folder in templates
    create index.html file in blogapp folder found in templates

create templates folder in the root directory
    create base.html file in templates folder found in root directory
make django know about the templates folder in settings.py file found in blogapp project folder

install Tailwind CSS (https://dev.to/jazzdev/setting-up-tailwindcss-with-django-easy-guide-2o6j) 
Step 1: Installing Tailwind CSS (These commands will install TailwindCSS, PostCSS, Autoprefixer and generate a tailwind.config.js default configuration file.)
    npm install -D tailwindcss postcss autoprefixer
    npx tailwindcss init

Step 2: Configuring TailwindCSS, change code in tailwind.config.js
Step 3: Configuring Postcss, In your project's root directory, create a new file named postcss.config.js
    add module.exports dictionary
Step 4:Add the Tailwind directives to your CSS
    Create a directory named static in your root directory. Inside this directory, create another directory named src, and within it, create a file named input.css. Add the following code to input.css
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

Step 5: Update your package.json
    Locate your package.json file in the root directory, and add the following line at the top of the devDependencies object:
        scripts dictionary

Step 6: Update your app templates layout.html or base.html
    In your app's templates directory, where your .html files are located, update the head section of your layout.html or base.html file with the following code. This ensures that your stylesheet points to the CSS files generated by Tailwind when you start the server:
        <link href="{% static 'src/styles.css' %}" rel="stylesheet">


Step 7: Update Django settings
    In your settings.py file, follow these steps:
        1. Import the os Module
        2. Configure Static Files Directory
            STATICFILES_DIRS = [os.path.join(BASE_DIR, "static")]

Step 8: Now open a new terminal aside the one running your django server and run:
    npm run dev


Implementing Auto-Reload in Django
If you find manual page reloading tedious while working on your Django project, you can set up automatic page reloads whenever your server code, templates, content, or classes change. Here's how to do it:
Step 1: Install django-browser-reload
    python -m pip install django-browser-reload
Step 2: Add django-browser-reload to your INSTALLED_APPS:
    In your Django project's settings, locate the INSTALLED_APPS list and add django_browser_reload to it:
Step 3: Include the App URLs
    Extend your project's URL configuration to include the django-browser-reload app's URLs. In your project's main urls.py (usually located in the project's root directory), add the following:
    path("__reload__/", include("django_browser_reload.urls")),
    this step ensures that the auto-reloading functionality is accessible at the __reload__/ endpoint of your Django project.
Step 4: Add the middleware:
    In your project's settings, locate the MIDDLEWARE list and 
    add django_browser_reload.middleware.BrowserReloadMiddleware to it. Make sure to place it after any other middleware that encodes the response, 
    such as Django's GZipMiddleware

create folder called assets in static folder (for all static files)

create urls.py file in blogapp

python manage.py runserver

create blog and category model

install pillow for images
    pip install pillow

admin.py blogapp add Blogapp models (blog and category),  Register  models
make slug field to auto populate, create BlogAdmin model
    class BlogAdmin(admin.ModelAdmin):
        prepopulated_fields = {"slug": ("title",)}

run migrations
    python manage.py makemigrations
    python manage.py migrate


python manage.py runserver

open djago admin http://127.0.0.1:8000/admin/login/?next=/admin/
emnanwork
create categories in django admin panel 

configure media files
STEP 1: configure media files (user uploaded), go to settings.py file in blogapp folder
    MEDIA_URL = 'img/' (accesing the files)
    MEDIA_ROOT = BASE_DIR/'media' (storing the files)

STEP 2: configure urls.py
import settings file
    from django.conf import settings
import static
    from django.conf.urls.static import static
add line urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

create blogs in django admin panel
render blog in page, views.py file blogapp
import Blog model
pass blogs 
go to index.html in blogapp templates and render the blogs

model.py file for blogapp
    add featured boolean field and category foreign key in Blog model

run migrations
    python manage.py makemigrations
    python manage.py migrate


python manage.py runserver

in views.py file, filter blog based on featured blog in index fxn and pass thro context to be renterd in index.html
get blogs where featured is false

render detailed and index page 

user authentication  (core app)
in core app
create forms.py file in core folder
create RegisterForm ( from UserCreationForm)
create signup fxn view in views.py

create templates folder in core app
    create core folder in templates
        create signup.html file in core folder found in templates

create urls.py file in core app folder
add core app urls.py in main app devdrive urls.py file
    path("user/", include("core.urls")),

in views.py file core app, add code for post method 
go to base.html file and add code for alert messages if the exist
install sweet alerts (https://sweetalert2.github.io/#download)
    npm install sweetalert2
    ***not working

login fxn (core app)
create login.html file in core folder found in templates
create signin fxn view in views.py 
create url path for signin in urls.py file 


signout fxn (core app)
create signout fxn view in views.py 
create url path for signout in urls.py file 

(https://flowbite.com/docs/getting-started/quickstart/)
1. install flowbite (design dropdown btn) 
    npm install flowbite
2. Require Flowbite as a plugin inside the tailwind.config.js file:
    require('flowbite/plugin')
 "./node_modules/flowbite/**/*.js"
3. Additionally to your own content data you should add flowbite to apply the classes from the interactive elements in the tailwind.config.js file:
    module.exports = {

        content: [
            "./node_modules/flowbite/**/*.js"
        ]

    }
4. Require the JavaScript code that powers the interactive elements before the end of your <body> tag:
    <script src="../path/to/flowbite/dist/flowbite.min.js"></script>

User Profile
create profile function for login view
create profile.html in core template folder
add profile path in urls.py 

in user models (CustomUser model) in models.py file 
    add profile picture field, address, phone, role, bio

run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver

create update_profile view 
create update_profile.html in core template folder (make sure form tag has:method="POST" action="" enctype="multipart/form-data")
add update_profile path in urls.py 
create UpdateProfileForm form for Updating Profile in form.py

Creating Articles from front end
blogapp app folder
create create_article view in views.py file
create html file create.html for article creation
add create_article path in urls.py 
create forms.py file 
create CreateBlogForm class in forms.py file 


Add user field to the blog model
in models.py file add user field
import settings in models.py file (from django.conf import settings)
user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, blank=True, null=True, related_name="blogs")
run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver

in views.py file 
create_article fxn add blog.user=request.user

in models.py file in blogapp make title field unique
    unique=True
run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver


in core app
get the blog create by the user in profile fxn view found in views.py and pass in context
    blogs = Blog.objects.filter(user=user)


add edit button in articles of a user in profile page
create update_article fxn in views.py file
add update article url path to urls.py
in profile.html file add the link to update the article in edit icon

create delete article fxn in views.py blogapp
add delete path in urls.py


Comments
create comment model in models.py in blogapp app
register comments in the admin, admin.py file
run migrations
    python manage.py makemigrations
    python manage.py migrate
python manage.py runserver
create a comment form in forms.py
got to views.py, details view add comment form (render in frontend)
in detail.html file render commentform received from detail view


make search functionality to work
in index.html file, add name="search" in search input
in index view fxn in views.py, get the search request
use Q to filter
    from django.db.models import Q 


paginating the blogs
in the views.py file import django pagination 
from django.core.paginator import Paginator
need to pass queryset to the pagination class
passing the paginator to the context, so that we can be able to use it in front end
in pagination section run a for loop to generate the paginator


Deploying app on render
- install guincorn
    pip install guincorn
- search django whitenoise 
    configure whitenoise (https://whitenoise.readthedocs.io/en/latest/)
    (https://medium.com/@karimmirzaguliyev/mastering-django-whitenoise-a-deep-dive-into-efficient-static-file-management-fa2aa5f669e6)
    pip install whitenoise
    add white noise middleware in settings.py file
        after "django.middleware.security.SecurityMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware",
    Want forever-cacheable files and compression support? Just add this to your settings.py
    for static files
        STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
- create a requirement.txt file (for all depencies of webapp)
    pip freeze > requirements.txt
- create build.sh file in root directory
 paste code in build.sh file (https://github.com/CodeWithClinton/django_24/blob/main/build.sh)
        #!/usr/bin/env bash

        set -o errexit  # exit on error

        pip install -r requirements.txt

        python manage.py collectstatic --no-input
        python manage.py migrate

In render when connection
start command (gunicorn setup) use 
    gunicorn devdrive.wsgi:application (since devdrive in the main app)
for build command use
    sh build.sh
fixed build failed, setup static root in settings.py file
    STATIC_ROOT = BASE_DIR/'assets'
    then commit and push changes to github using git bash

In render app
    click on manual deploy and select deploy latest commit
    if build in successful
    copy link under service name and github project name
    https://devdrive.onrender.com and add in allowed host in settings.py file
        ALLOWED_HOSTS = [
            "devdrive.onrender.com",
            "127.0.0.1",
            "localhost"
        ]
    then commit and push changes to github using git bash


to run app (command prompt)
    npm run dev
    python manage.py runserver



















