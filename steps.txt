
pip install virtualenvwrapper-win
mkvirtualenv devdriveenv
pip install django
django-admin startproject devdrive

python manage.py startapp core
register core app in devdrive main folder in INSTALLED_APPS (settings.py file)
in core folder, models.py file, import abstract user

in settings.py file set AUTH_USER_MODEL to 'core.CustomUser'

import user admin in admin.py in core folder
import CustomUser
create CustomUserAdmin 
run migrations
    python manage.py makemigrations
    python manage.py migrate

create superuser
python manage.py createsuperuser

python manage.py runserver


python manage.py startapp blogapp

create index function in views.py in blogapp folder
create templates folder in blogapp
create blogapp folder in templates
    create index.html file in blogapp folder found in templates

create templates folder in the root directory
    create base.html file in templates folder found in root directory
make django know about the templates folder in settings.py file found in blogapp project folder

install Tailwind CSS (https://dev.to/jazzdev/setting-up-tailwindcss-with-django-easy-guide-2o6j) 
Step 1: Installing Tailwind CSS (These commands will install TailwindCSS, PostCSS, Autoprefixer and generate a tailwind.config.js default configuration file.)
    npm install -D tailwindcss postcss autoprefixer
    npx tailwindcss init

Step 2: Configuring TailwindCSS, change code in tailwind.config.js
Step 3: Configuring Postcss, In your project's root directory, create a new file named postcss.config.js
    add module.exports dictionary
Step 4:Add the Tailwind directives to your CSS
    Create a directory named static in your root directory. Inside this directory, create another directory named src, and within it, create a file named input.css. Add the following code to input.css
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

Step 5: Update your package.json
    Locate your package.json file in the root directory, and add the following line at the top of the devDependencies object:
        scripts dictionary

Step 6: Update your app templates layout.html or base.html
    In your app's templates directory, where your .html files are located, update the head section of your layout.html or base.html file with the following code. This ensures that your stylesheet points to the CSS files generated by Tailwind when you start the server:
        <link href="{% static 'src/styles.css' %}" rel="stylesheet">


Step 7: Update Django settings
    In your settings.py file, follow these steps:
        1. Import the os Module
        2. Configure Static Files Directory
            STATICFILES_DIRS = [os.path.join(BASE_DIR, "static")]

Step 8: Now open a new terminal aside the one running your django server and run:
    npm run dev


Implementing Auto-Reload in Django
If you find manual page reloading tedious while working on your Django project, you can set up automatic page reloads whenever your server code, templates, content, or classes change. Here's how to do it:
Step 1: Install django-browser-reload
    python -m pip install django-browser-reload
Step 2: Add django-browser-reload to your INSTALLED_APPS:
    In your Django project's settings, locate the INSTALLED_APPS list and add django_browser_reload to it:
Step 3: Include the App URLs
    Extend your project's URL configuration to include the django-browser-reload app's URLs. In your project's main urls.py (usually located in the project's root directory), add the following:
    path("__reload__/", include("django_browser_reload.urls")),
    this step ensures that the auto-reloading functionality is accessible at the __reload__/ endpoint of your Django project.
Step 4: Add the middleware:
    In your project's settings, locate the MIDDLEWARE list and 
    add django_browser_reload.middleware.BrowserReloadMiddleware to it. Make sure to place it after any other middleware that encodes the response, 
    such as Django's GZipMiddleware

create folder called assets in static folder (for all static files)

create urls.py file in blogapp

python manage.py runserver

create blog and category model

install pillow for images
    pip install pillow

admin.py blogapp add Blogapp models (blog and category),  Register  models
make slug field to auto populate, create BlogAdmin model
    class BlogAdmin(admin.ModelAdmin):
        prepopulated_fields = {"slug": ("title",)}

run migrations
    python manage.py makemigrations
    python manage.py migrate


python manage.py runserver

open djago admin http://127.0.0.1:8000/admin/login/?next=/admin/
emnanwork
create categories in django admin panel 

configure media files
STEP 1: configure media files (user uploaded), go to settings.py file in blogapp folder
    MEDIA_URL = 'img/' (accesing the files)
    MEDIA_ROOT = BASE_DIR/'media' (storing the files)

STEP 2: configure urls.py
import settings file
    from django.conf import settings
import static
    from django.conf.urls.static import static
add line urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

create blogs in django admin panel
render blog in page, views.py file blogapp
import Blog model
pass blogs 
go to index.html in blogapp templates and render the blogs

model.py file for blogapp
    add featured boolean field and category foreign key in Blog model

run migrations
    python manage.py makemigrations
    python manage.py migrate


python manage.py runserver

in views.py file, filter blog based on featured blog in index fxn and pass thro context to be renterd in index.html
get blogs where featured is false

render detailed and index page 

user authentication  (core app)
in core app
create forms.py file in core folder
create RegisterForm ( from UserCreationForm)
create signup fxn view in views.py

create templates folder in core app
    create core folder in templates
        create signup.html file in core folder found in templates

create urls.py file in core app folder
add core app urls.py in main app devdrive urls.py file
    path("user/", include("core.urls")),

in views.py file core app, add code for post method 
go to base.html file and add code for alert messages if the exist
install sweet alerts (https://sweetalert2.github.io/#download)
    npm install sweetalert2
    ***not working

login fxn (core app)
create login.html file in core folder found in templates
create signin fxn view in views.py 
create url path for signin in urls.py file 


signout fxn (core app)
create signout fxn view in views.py 
create url path for signout in urls.py file 

(https://flowbite.com/docs/getting-started/quickstart/)
1. install flowbite (design dropdown btn) 
    npm install flowbite
2. Require Flowbite as a plugin inside the tailwind.config.js file:
    require('flowbite/plugin')
 "./node_modules/flowbite/**/*.js"
3. Additionally to your own content data you should add flowbite to apply the classes from the interactive elements in the tailwind.config.js file:
    module.exports = {

        content: [
            "./node_modules/flowbite/**/*.js"
        ]

    }
4. Require the JavaScript code that powers the interactive elements before the end of your <body> tag:
    <script src="../path/to/flowbite/dist/flowbite.min.js"></script>

User Profile
create profile function for login view
create profile.html in core template folder
add profile path in urls.py 

in user models (CustomUser model) in models.py file 
    add profile picture field, address, phone, role, bio

run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver

create update_profile view 
create update_profile.html in core template folder (make sure form tag has:method="POST" action="" enctype="multipart/form-data")
add update_profile path in urls.py 
create UpdateProfileForm form for Updating Profile in form.py

Creating Articles from front end
blogapp app folder
create create_article view in views.py file
create html file create.html for article creation
add create_article path in urls.py 
create forms.py file 
create CreateBlogForm class in forms.py file 


Add user field to the blog model
in models.py file add user field
import settings in models.py file (from django.conf import settings)
user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, blank=True, null=True, related_name="blogs")
run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver

in views.py file 
create_article fxn add blog.user=request.user

in models.py file in blogapp make title field unique
    unique=True
run migrations
    python manage.py makemigrations
    python manage.py migrate

python manage.py runserver


in core app
get the blog create by the user in profile fxn view found in views.py and pass in context
    blogs = Blog.objects.filter(user=user)


add edit button in articles of a user in profile page
create update_article fxn in views.py file
add update article url path to urls.py
in profile.html file add the link to update the article in edit icon

create delete article fxn in views.py blogapp
add delete path in urls.py


Comments
create comment model in models.py in blogapp app
register comments in the admin, admin.py file
run migrations
    python manage.py makemigrations
    python manage.py migrate
python manage.py runserver
create a comment form in forms.py
got to views.py, details view add comment form (render in frontend)
in detail.html file render commentform received from detail view


make search functionality to work
in index.html file, add name="search" in search input
in index view fxn in views.py, get the search request
use Q to filter
    from django.db.models import Q 


paginating the blogs
in the views.py file import django pagination 
from django.core.paginator import Paginator
need to pass queryset to the pagination class
passing the paginator to the context, so that we can be able to use it in front end
in pagination section run a for loop to generate the paginator


Deploying app on render
- install guincorn
    pip install gunicorn
- search django whitenoise 
    configure whitenoise (https://whitenoise.readthedocs.io/en/latest/)
    (https://medium.com/@karimmirzaguliyev/mastering-django-whitenoise-a-deep-dive-into-efficient-static-file-management-fa2aa5f669e6)
    pip install whitenoise
    add white noise middleware in settings.py file
        after "django.middleware.security.SecurityMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware",
    Want forever-cacheable files and compression support? Just add this to your settings.py
    for static files
        STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
- create a requirement.txt file (for all depencies of webapp)
    pip freeze > requirements.txt
- create build.sh file in root directory
 paste code in build.sh file (https://github.com/CodeWithClinton/django_24/blob/main/build.sh)
        #!/usr/bin/env bash

        set -o errexit  # exit on error

        pip install -r requirements.txt

        python manage.py collectstatic --no-input
        python manage.py migrate

In render when connection
start command (gunicorn setup) use 
    gunicorn devdrive.wsgi:application (since devdrive in the main app)
for build command use
    sh build.sh
fixed build failed, setup static root in settings.py file
    STATIC_ROOT = BASE_DIR/'assets'
    then commit and push changes to github using git bash

In render app
    click on manual deploy and select deploy latest commit
    if build in successful
    copy link under service name and github project name
    https://devdrive.onrender.com and add in allowed host in settings.py file
        ALLOWED_HOSTS = [
            "devdrive.onrender.com",
            "127.0.0.1",
            "localhost"
        ]
    then commit and push changes to github using git bash

install back gunicorn then run pip freeze > requirements.txt
then commit and push changes to github using git bash

to run app (command prompt)
    npm run dev
    python manage.py runserver


API
python manage.py runserver
pip install djangorestframework
add djangorestframework ('rest_framework',) to INSTALLED_APPS in main project devdrive seetings.py file

create api app 
    python manage.py startapp drf
add drf api app in INSTALLED_APPS in main project devdrive seetings.py file

create serializers.py file in drf app folder (make all model into json form)
in serializers.py file import serializers
     from rest_framework import serializers
import all models into serializers.py file
    starting with blogapp models (from blogapp.models import Blog, Comment)
create a serializers for Blog model BlogSerializer

function based views
in views.py files import api_views
    from rest_framework.decorators import api_views
import BlogSerializer 
    from drf.serializers import BlogSerializer
import Blog model
    from blogapp.models import Blog
create urls.py file in drf app folder
    from django.urls import path
    from . import views
in main folder devdrive urls.py add drf urls.py file 
    path("api/", include("drf.urls")),

python manage.py runserver


for the post request we have to deserializers the post request to get the data

in blogapp app models.py file add the save method to set the slugify value of title as slug value before saving or blod creation
    from django.utils.text import slugify
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super(Blog, self).save(*args, **kwargs)

python manage.py runserver


test blog post method in drf views with POSTMAN
    http://127.0.0.1:8000/api/blogs (POST)
    select body
        select form-data
        key (put fields: title(on the dropdown leave default Text), (as value write a text)
                body(on the dropdown leave default Text), (as value write a text)
                thumpnail(on the dropdown select File), (as value select the file)
                category(on the dropdown leave default Text) (as value pass the id e.g 1)
            )
    Then click on Send button
    error key slug is required
        add key slug and value (title slugify: pandas-full-course)
        "title": "Pandas Full Course",
        "slug": "pandas-full-course",
        "body": "PANDAS FOR BEGINNERS",
        "thumpnail": "/img/img/pandas.png",
        "category": 1,
    if no error it show all the blogs ie GET method

drf views.py file
for the update and delete function
import get_object_or_404
    from django.shortcuts import get_object_or_404
create blog_detail function and get blog with primary key 
    def blog_detail(request, pk)
add the api view decorators @api_view(['GET', 'PUT', 'DELETE'])
in urls.py file add path to blog_detail
    path("blogs/<int:pk>", views.blog_detail)

python manage.py runserver

Class based views
in views.py file
    import APIView (from rest_framework.views import APIView) 
    create BlogDetailAPIView class, pass APIView as argument


api with ModelViewSet
in views import ModelViewSet
    from rest_framework.viewsets import ModelViewSet
create blog model view set
    class BlogModelViewSet(ModelViewSet):
        serializer_class = BlogSerializer
        queryset = Blog.objects.all()

in urls.py file use DefaultRouter from rest_framework routers
    from rest_framework.routers import DefaultRouter (import)

    router = DefaultRouter()

    router.register("blogs", views.BlogModelViewSet)

    urlpatterns = [
        path("", include(router.urls)),
    ]

to create a post require login ie authorize user using djoser
https://djoser.readthedocs.io/en/latest/getting_started.html
Installation
    pip install -U djoser


Configuration¶
    Configure INSTALLED_APPS:

    INSTALLED_APPS = (
        'django.contrib.auth',
        (...),
        'rest_framework',
        'djoser',
        (...),
    )
Configure urls.py:

    urlpatterns = [
        (...),
        path('auth/', include('djoser.urls')),
    ]


If you are going to use JWT authentication, you will also need to install djangorestframework_simplejwt with:

    pip install -U djangorestframework_simplejwt

https://djoser.readthedocs.io/en/latest/authentication_backends.html


add the following in the btm of project settings.py file
    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES': (
            'rest_framework_simplejwt.authentication.JWTAuthentication',
           
        ),
    }

Configure django-rest-framework-simplejwt to use the Authorization: JWT <access_token> header:

    SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),
    }

urls.py¶
Configure urls.py with djoser.url.jwt module path:

urlpatterns = [
    (...),
    url(r'^auth/', include('djoser.urls')),
    url(r'^auth/', include('djoser.urls.jwt')),
]


https://djoser.readthedocs.io/en/latest/getting_started.html
Getting started¶
Available endpoints¶
/users/
/users/me/
/users/confirm/
/users/resend_activation/
/users/set_password/
/users/reset_password/
/users/reset_password_confirm/
/users/set_username/
/users/reset_username/
/users/reset_username_confirm/
/token/login/ (Token Based Authentication)
/token/logout/ (Token Based Authentication)
/jwt/create/ (JSON Web Token Authentication)
/jwt/refresh/ (JSON Web Token Authentication)
/jwt/verify/ (JSON Web Token Authentication)

Supported authentication backends¶
Token based authentication from DRF

JSON Web Token authentication from django-rest-framework-simplejwt

to test jwt login using browser use mod header extension
    https://chromewebstore.google.com/detail/modheader-modify-http-hea/idgpnmonknjnojddfkpgkljpfnnfcklj?pli=1


to make the access token last more than 5min
https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=5), (change 5 to 60)


use djoser serializers
SERIALIZERS¶ (https://djoser.readthedocs.io/en/latest/settings.html)
Dictionary which maps djoser serializer names to serializer classes (use dotted path). This setting provides a way to easily override given serializer(s) - it is used to update the defaults, so by providing, e.g. one key, all the others will stay default.
Note
Key 'user' is used for general users whereas 'current_user' lets you set serializer for special /users/me endpoint. They both default to the same serializer though.
Examples
    {
        'user': 'myapp.serializers.SpecialUserSerializer',
    }


python manage.py runserver


how to add more user information in user profile route (http://127.0.0.1:8000/auth/users/me/)
    which can be modified
    get the current_user serializers (https://djoser.readthedocs.io/en/latest/settings.html)
        'current_user': 'djoser.serializers.UserSerializer',
        we can customize the serializer to tame more fields
in serializer.py file
    import user serializer (from djoser.serializers import UserSerializer)
    import get_user_model (from django.contrib.auth import get_user_model)
    create CustomUserSerializer class and use get_user_model as model

go to settings.py file
    let django know about CustomUserSerializer
    DJOSER = {
        'SERIALIZERS': {
            'current_user': 'drf.serializers.CustomUserSerializer'
        }
    }


python manage.py runserver


01:36:00
